---
title: c语言中浮点型的存储方式
mathjax: true
date: 2020-03-11
tags:
- 浮点数 
---

> 在计算机中，所有数据都是以二进制的形式保存的，浮点数也不例外。

<!--more-->

## 保存的过程
1.先将浮点数转化为二进制数据。
2.将二进制形式转换成二进制的指数形式。
3.将指数形式的各部分分别保存到内存约定的位置上。

## 内存结构

在c语言中，float类型一般占32位。IEEE754标准单精度浮点型格式，在内存中的结构如下：

![](/images/float_mem.png)

float所占据的32位被分成了三个部分，符号(sign)，指数(exponent)，小数(fraction)。


- 符号位: 只占一个最高位，0表示正，1表示负数。
- 指数部分: 占8位，可以表示[0, 255]范围内的数字，由于指数部分可能是负数，所以约定exponent=c-127,(c为指数部分在内存中的实际值)，这样exponent的范围就是[-127, 128]。
- 小数部分: 因为在把浮点数转换成二进制指数的时候，总是保证 1 ≤ fraction < 2, 这样的话，小数点前的数字永远是1，就不用存了，内存中只保存小数点后的数字，称之为尾数(m)。

计算一个浮点数实际值的公式为:

$$
value = (-1)^{sign} × fraction × 2^{exponent}
$$

$$
with : exponent = c - 127;    fraction = 1 + m
$$

## 一个具体🌰
以浮点数`3.4`为例，来探究其在内存中实际是如何存储的。

### 第一步：转换成二进制形式

10进制的小数转换成二进制与整数的转换是不同的，可以采用乘2取整法。
> 乘2取整法，即将小数部分乘以2，然后取整数部分，剩下的小数部分继续乘以2，然后取整数部分，剩下的小数部分又乘以2，一直取到小数部分为零为止。

1. `3.4`的整数部分为3，转换成二进制还是11。重点是小数部分也就是`0.4`如何转换成二进制。
2. `0.4` × 2 = 0.8。整数部分为0, 小数部分为0.8。
3. `0.8` × 2 = 1.6。整数部分为1, 小数部分为0.6。
4. `0.6` × 2 = 1.2。整数部分为1, 小数部分为0.2。
3. `0.2` × 2 = 0.4。整数部分为0, 小数部分为0.4。
...

不难发现，小数部分应用不可能为0，这就变成了死循环，实际这个过程计算到小数点后一定的位数就停止了，最后取一个近似值。最终得到的二进制小数形式为: `11.0110`。

### 第二步：转换成二进制指数
这一步比较简单，`11.0110`转换成二进制就是 1.10110 × 2 ^ 1。

### 第三部：存储到内存
套用上面的公式，sign = 0, fraction = 1.10110..., exponent = 1。
进而计算出c = 128, m = 0.10110...。内存中只保存小数点后的数字，即10110...。
可以得到浮点数1.4在内存中的每一位就是: `0  10000000   10110..........`


## 验证
通过下面的一段c代码，验证浮点数`3.4`在内存中的存储是否符合上面的计算。
```c
#include<stdio.h>

int main(void) {

    float num = 3.4;
    int int_num = *(int *)&num;

    for (int i = 31; i >= 0; i--)
    {
        if (int_num & (1 << i)) {
            printf("1");
        } else {
           printf("0");
        }
    }

    printf("\n");
    return 0;   

    // 最终输出结果为 01000000010110011001100110011010
}
```

## 总结
浮点数在c语言中也是以二进制保存在内存中的，由于浮点数一般只占32位或64位空间，所以并不能精确地表示所有10进制小数，也就是存在精度的损失。double float 由于小数部分和指数部分占用的空间都比float多，所以精度更高。

计算机在保存浮点数的时候，精度丢失实际是发生在将浮点数转成二进制小数的过程中，最后一位小数不是0或5的浮点数，采用乘2取整法的时候，循环永远无法结束，只能取一个近似值(0舍1入)。

对于一些精度要求极高的程序，使用c语言的浮点类型是不合适的，这时候需要一些专门用于高精度计算的包，各个语言也有各自的实现方式。但是使用这些包的情况下，总是不可避免地带来计算效率上的损失。看你如何在时间与精度之间取舍了。